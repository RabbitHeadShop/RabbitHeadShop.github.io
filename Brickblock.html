<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google Tag Manager -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TXZX351KJ2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-TXZX351KJ2');
</script>
<!-- End Google Tag Manager -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrickBlock</title>
    <style>
        body, html {
            background-color: #000;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            color: purple;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: none;
        }
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center vertically */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin-bottom: 20px;
        }
        .button-container button {
            width: 200px;
            background-color: red;
            border: groove;
            border-color: purple;
            border-width: 5px;
            color: purple;
            padding: 15px 32px;
            font-family: Arial, sans-serif;
            text-align: center;
            text-decoration: none;
            font-size: 16px;
            margin: 10px 0;
            cursor: pointer;
        }
        .start-button, .game-over-buttons button, .fullscreen-button {
            background-color: #4CAF50;
        }
        .game-over-buttons {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        .game-over-buttons p {
            font-size: 24px;
            margin-bottom: 10px;
        }
        .game-over-buttons .score {
            font-size: 18px;
        }
        .game-over-buttons button {
            background-color: #f44336;
            margin: 10px auto;
        }
        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
    </style>
<!-- Measurement ID -->
    <script>
        gtag('config', 'G-TXZX351KJ2', { 'send_page_view': true });
    </script>
    <!-- End Measurement ID -->
</head>
<body>
    <div class="button-container">
        <div class="difficulty-buttons">
            <button onclick="setDifficulty('very_easy')">Very Easy</button>
            <button onclick="setDifficulty('easy')">Easy</button>
            <button onclick="setDifficulty('medium')">Medium</button>
            <button onclick="setDifficulty('hard')">Hard</button>
            <button class="fullscreen-button" onclick="toggleFullscreen()">Fullscreen</button>
        </div>
        <button class="start-button" id="startButton" style="display: none;" onclick="startGame()">Start Game</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="gameOverScreen" class="game-over-buttons">
        <p id="gameOverText">Game Over</p>
        <p class="score" id="scoreText"></p>
        <p class="high-score" id="highScoreText"></p>
        <button onclick="restartGame()">Restart</button>
        <button onclick="backToDifficulty()">Home</button>
        <button class="fullscreen-button" onclick="toggleFullscreen()">Fullscreen</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        let square = { x: 0, y: 0, size: 50 };
        let obstacles = [];
        const obstacleHeight = 60;
        let touchX = null; // Only X-axis touch input, null initially
        let obstacleSpeed = 4;
        let gameOver = false;
        let gameStarted = false;
        let obstacleDistance; // Distance between obstacles in pixels
        let score = 0; // Initialize score variable
        let highScores = {
            very_easy: 0,
            easy: 0,
            medium: 0,
            hard: 0
        };

        // Load high scores from localStorage if available
        if (localStorage.getItem('highScores')) {
            highScores = JSON.parse(localStorage.getItem('highScores'));
        }

        // Image for square
        const squareImage = new Image();
        squareImage.src = 'https://raw.githubusercontent.com/RabbitHeadShop/RabbitHeadShop.github.io/main/Parachute.png';

        // Image for obstacle
        const obstacleImage = new Image();
obstacleImage.src = 'https://cdn.vectorstock.com/i/preview-1x/53/77/pixel-art-seamless-pattern-brick-texture-vector-30705377.jpg';
obstacleImage.width = 300;
obstacleImage.height = 300;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Center the square in the viewport
            square.x = canvas.width / 2 - square.size / 2;
            square.y = canvas.height / 2 - square.size / 2;

            draw();
        }

        function draw() {
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.drawImage(squareImage, square.x, square.y, square.size, square.size);

    obstacles.forEach(obstacle => {
        obstacles.forEach(obstacle => {
    // Draw left part of obstacle with repeated brick texture
    let leftPartWidth = obstacle.holeX;
    while (leftPartWidth > 0) {
        let widthToDraw = Math.min(leftPartWidth, obstacleImage.width);
        context.drawImage(
            obstacleImage,
            0,
            0,
            widthToDraw,
            obstacle.height,
            obstacle.holeX - leftPartWidth,
            obstacle.y,
            widthToDraw,
            obstacle.height
        );
        leftPartWidth -= widthToDraw;
    }

    // Draw right part of obstacle with repeated brick texture
    let rightPartWidth = canvas.width - (obstacle.holeX + obstacle.holeWidth);
    let rightX = obstacle.holeX + obstacle.holeWidth;
    while (rightPartWidth > 0) {
        let widthToDraw = Math.min(rightPartWidth, obstacleImage.width);
        context.drawImage(
            obstacleImage,
            0,
            0,
            widthToDraw,
            obstacle.height,
            rightX,
            obstacle.y,
            widthToDraw,
            obstacle.height
        );
        rightX += widthToDraw;
        rightPartWidth -= widthToDraw;
    }
});
    });

    if (gameOver) {
        context.fillStyle = 'white';
        context.font = '20px Arial';
        context.fillText(`Score: ${score}`, 10, 30);
        const currentDifficulty = getCurrentDifficulty();
        context.fillText(`High Score (${currentDifficulty}): ${highScores[currentDifficulty]}`, 10, 60);
    }
}

        function update() {
    if (gameStarted) {
        if (touchX !== null) {
            // Move square based on touch (only X-axis)
            square.x = touchX - square.size / 2;

            // Ensure square stays within bounds of canvas horizontally
            square.x = Math.max(0, Math.min(canvas.width - square.size, square.x));
        }

        // Update obstacle positions
        obstacles.forEach(obstacle => {
            obstacle.y -= obstacleSpeed;

            // Check if obstacle has passed the square
            if (obstacle.y + obstacle.height < square.y && !obstacle.passed) {
                obstacle.passed = true;
                score++; // Increment score

                // Update high score if current score is higher
                const currentDifficulty = getCurrentDifficulty();
                if (score > highScores[currentDifficulty]) {
                    highScores[currentDifficulty] = score;
                    localStorage.setItem('highScores', JSON.stringify(highScores));
                }
            }
        });

        // Remove obstacles that are off-screen
        obstacles = obstacles.filter(obstacle => obstacle.y + obstacle.height > 0);

        // Check for collisions
        obstacles.forEach(obstacle => {
            if (
                (square.x < obstacle.holeX &&
                    square.x + square.size > 0 &&
                    square.y < obstacle.y + obstacle.height &&
                    square.y + square.size > obstacle.y) ||
                (square.x < canvas.width &&
                    square.x + square.size > obstacle.holeX + obstacle.holeWidth &&
                    square.y < obstacle.y + obstacle.height &&
                    square.y + square.size > obstacle.y)
            ) {
                // Collision detected, stop the game
                gameOver = true;
            }
        });

        // Create new obstacles based on distance
        if (obstacles.length === 0 || obstacles[obstacles.length - 1].y <= canvas.height - obstacleDistance) {
            obstacles.push(createObstacle());
        }
    }

    if (gameOver) {
        stopGame();
    } else {
        draw();
        requestAnimationFrame(update);
    }
}

        function stopGame() {
            canvas.style.display = 'none'; // Hide the canvas
            document.getElementById('gameOverScreen').style.display = 'block';
            document.getElementById('scoreText').textContent = `Score: ${score}`; // Display score
            const currentDifficulty = getCurrentDifficulty();
            document.getElementById('highScoreText').textContent = `High Score (${currentDifficulty}): ${highScores[currentDifficulty]}`; // Display high score
            score = 0; // Reset score
        }

        function restartGame() {
            gameOver = false;
            canvas.style.display = 'none'; //Hide the canvas
            document.getElementById('gameOverScreen').style.display = 'none';
            resetGame();
            score = 0; // Reset score
            startGame(); // Restart the game
        }

        function backToDifficulty() {
            gameOver = false;
            canvas.style.display = 'none'; // Hide the canvas
            document.getElementById('gameOverScreen').style.display = 'none';
            document.querySelector('.difficulty-buttons').style.display = 'flex'; // Show difficulty buttons
            document.querySelector('.start-button').style.display = 'none'; // Hide start button
        }

        function setDifficulty(difficulty) {
            switch (difficulty) {
                case 'very_easy':
                    obstacleSpeed = 4;
                    obstacleDistance = 400; // Pixels between obstacles
                    break;
                case 'easy':
                    obstacleSpeed = 5;
                    obstacleDistance = 350;
                    break;
                case 'medium':
                    obstacleSpeed = 6;
                    obstacleDistance = 300;
                    break;
                case 'hard':
                    obstacleSpeed = 7;
                    obstacleDistance = 250;
                    break;
                default:
                    obstacleSpeed = 4;
                    obstacleDistance = 300;
            }
            document.querySelector('.difficulty-buttons').style.display = 'none'; // Hide difficulty buttons
            document.querySelector('.start-button').style.display = 'block'; // Show start button
        }

        function getCurrentDifficulty() {
            if (obstacleSpeed === 4) return 'very_easy';
            if (obstacleSpeed === 5) return 'easy';
            if (obstacleSpeed === 6) return 'medium';
            if (obstacleSpeed === 7) return 'hard';
            return 'medium';
        }

        function createObstacle() {
            const holeWidth = 150; // Width of the hole in the obstacle
            const holeX = Math.floor(Math.random() * (canvas.width - holeWidth));
            return { y: canvas.height, height: obstacleHeight, holeX, holeWidth, passed: false };
        }

        function resetGame() {
            obstacles = [];
            score = 0;
            gameOver = false;
            gameStarted = false;
        }

        function startGame() {
            resetGame();
            canvas.style.display = 'block';
            document.getElementById('startButton').style.display = 'none';
            gameStarted = true;
            resizeCanvas();
            requestAnimationFrame(update);
        }

        window.addEventListener('resize', resizeCanvas);

        canvas.addEventListener('touchstart', function (event) {
            if (event.touches.length === 1) {
                touchX = event.touches[0].clientX;
            }
        });

        canvas.addEventListener('touchmove', function (event) {
            if (event.touches.length === 1) {
                touchX = event.touches[0].clientX;
            }
        });

        canvas.addEventListener('touchend', function () {
            touchX = null; // Reset touch input when touch ends
        });

        // Fullscreen functionality
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable full-screen mode: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Initial setup
        resizeCanvas();
        draw();
    </script>
</body>
</html>
